# Microsoft BASIC 6502 解释器完整代码分析报告

## 1. 概述

这是 Microsoft 为 6502 微处理器开发的 BASIC 1.1 解释器源代码，约 6954 行汇编代码，代表了 1970 年代末期计算机软件工程的巅峰之作。

### 基本信息
- **版本**: 1.1
- **开发时间**: 1976-1978
- **目标处理器**: MOS Technology 6502 (8位)
- **内存占用**: 8KB ROM 版本
- **支持平台**: Apple II, Commodore PET, OSI, KIM-1, PDP-10

## 2. 代码结构分析

### 2.1 主要模块划分（按 SUBTTL 标记）

```
行号范围        模块名称                          功能说明
--------        --------                          --------
8-205          开关和宏定义                       编译配置、宏定义
206-244        引言和编译参数                     版本历史、常量定义
245-729        说明文档                          内存布局说明
730-942        零页内存定义                       快速访问变量区
943-992        RAM 代码                          运行时代码
993-1365       调度表、保留字、错误文本            语言关键字定义
1366-1514      通用存储管理例程                   内存管理
1515-1972      错误处理、就绪、输入、编译、初始化   核心控制流
1973-2063      LIST 命令                         程序列表功能
2064-2130      FOR 语句                          循环语句
2131-2193      语句获取器                        执行调度
2194-2278      RESTORE、STOP、END、CONTINUE 等    控制语句
2279-2364      LOAD 和 SAVE 子程序               文件I/O
2365-2463      RUN、GOTO、GOSUB、RETURN          程序流控制
2464-2478      IF...THEN 代码                    条件语句
2479-2496      ON...GOTO 代码                    多路分支
2497-2538      LINGET - 读取行号                 输入解析
2539-2654      LET 代码                          赋值语句
2655-2851      PRINT 代码                        输出功能
2852-3093      INPUT 和 READ 代码                输入功能
3094-3163      NEXT 代码                         循环结束
3164-3598      表达式求值代码                     核心求值引擎
3599-3779      维度和变量搜索                     变量管理
3780-4075      多维代码                          数组处理
4076-4111      整数算术例程                       整数运算
4112-4133      FRE 函数和整数转浮点               类型转换
4134-4235      用户定义函数代码                   DEF FN
4236-4790      字符串函数                        字符串处理
4791-4844      PEEK、POKE 和 FNWAIT              内存访问
4845-4898      浮点数学包配置                     浮点数说明
4899-5164      浮点加减法                        基础运算
5165-5261      自然对数函数                       LOG
5262-5462      浮点乘除法                        乘除运算
5463-5558      浮点数移动例程                     数据传输
5559-5597      符号、SGN、浮点、取负、绝对值       基础函数
5598-5639      比较两个数                        比较运算
5640-5693      最大整数函数                       INT
5694-5808      浮点输入例程                       数字解析
5809-6101      浮点输出例程                       数字格式化
6102-6152      幂运算和平方根函数                 SQR
6153-6286      幂运算函数                        指数运算
6287-6399      多项式求值器和随机数生成器          RND
6400-6540      正弦、余弦和正切函数               三角函数
6541-6669      反正切函数                        ATN
6670-6954      系统初始化代码                     启动初始化
```

## 3. 核心数据结构

### 3.1 零页变量（730-942行）

零页是 6502 处理器最快的内存区域，存放最常用的变量：

```assembly
CHARAC:   字符分隔符
ENDCHR:   结束字符
DIMFLG:   DIM 标志
VALTYP:   值类型指示器（0=数值，1=字符串）
INTFLG:   整数标志
DORES:    是否压缩保留字
SUBFLG:   是否允许下标变量
INPFLG:   INPUT/READ 标志
TANSGN:   正切符号
CHANNL:   通道号
TRMPOS:   终端光标位置
LINWID:   行宽度
LINNUM:   行号
BUF:      输入缓冲区（72字节）
TEMPPT:   临时描述符指针
TXTTAB:   程序文本起始指针
VARTAB:   简单变量起始指针
ARYTAB:   数组表起始指针
STREND:   已用存储结束
FRETOP:   字符串空闲空间顶部
MEMSIZ:   内存最高位置
CURLIN:   当前行号
DATPTR:   DATA 指针
VARNAM:   变量名
VARPNT:   变量指针
FAC:      浮点累加器（5字节）
ARGEXP:   参数（5字节）
```

### 3.2 浮点数格式（4845-4898行）

```
格式说明：
- 符号位：尾数的第一位
- 尾数：24位
- 指数：8位带符号数 + 200（偏移量）
- 存储格式：
  [指数字节]
  [符号位在第7位，尾数的2-8位在6-0位]
  [尾数的9-16位]
  [尾数的17-24位]

示例：
指数为0表示数字为0
二进制小数点在最高有效位左侧
数值 = 尾数 × 2^指数
```

### 3.3 内存布局

```
低地址
├── 零页 (0-255)
│   ├── 启动跳转
│   ├── FAC到整数/整数到FAC例程地址
│   ├── 常用变量和指针
│   └── CHRGET 子程序
├── 栈 (256-511)
├── 存储区 (512+)
│   ├── [TXTTAB] 程序文本
│   │   ├── 0
│   │   ├── 指向下一行的指针 (2字节)
│   │   ├── 行号 (2字节)
│   │   ├── 行内容（tokenized）
│   │   ├── 0（行结束符）
│   │   └── ... 重复 ...
│   ├── [VARTAB] 简单变量（每个6字节）
│   │   ├── 变量名 (2字节)
│   │   └── 值 (4字节浮点)
│   ├── [ARYTAB] 数组变量
│   │   ├── 名称 (2字节)
│   │   ├── 长度 (2字节)
│   │   ├── 维数 (1字节)
│   │   ├── 每维范围 (2字节/维)
│   │   └── 数值
│   └── [STREND] 已用内存结束
└── [FRETOP] 字符串空间（从高地址向下增长）
高地址
```

## 4. 语言特性分析

### 4.1 支持的关键字（1112-1245行）

**语句类关键字**:
```
END, FOR, NEXT, DATA, INPUT, INPUT#, DIM, READ, LET
GOTO, RUN, IF, RESTORE, GOSUB, RETURN, REM, STOP
ON, NULL, WAIT, LOAD, SAVE, VERIFY (Commodore)
DEF, POKE, PRINT, PRINT#, CONT, LIST, CLEAR/CLR
CMD, SYS, OPEN, CLOSE (扩展I/O), GET, NEW
```

**运算符和控制字**:
```
TAB(, TO, FN, SPC(, THEN, NOT, STEP
+, -, *, /, ^, AND, OR, >, =, <
```

**内置函数**:
```
数学函数: SGN, INT, ABS, SQR, RND, LOG, EXP
        COS, SIN, TAN, ATN
字符串函数: LEN, STR$, VAL, ASC, CHR$
          LEFT$, RIGHT$, MID$
系统函数: USR, FRE, POS, PEEK
```

### 4.2 Token化系统

- 所有保留字的 token 值 >= 128（最高位为1）
- Token 在输入时由 "crunch" 过程生成
- 节省内存空间和加快执行速度
- 示例：
  - END = 128
  - FOR = 129
  - PRINT = 153
  - GOTO = 137

### 4.3 错误处理（1251-1351行）

支持的错误类型：
```
NF - NEXT WITHOUT FOR
SN - SYNTAX ERROR
RG - RETURN WITHOUT GOSUB
OD - OUT OF DATA
FC - ILLEGAL QUANTITY
OV - OVERFLOW
OM - OUT OF MEMORY
US - UNDEFINED STATEMENT
BS - BAD SUBSCRIPT
DD - REDIMENSIONED ARRAY
/0 - DIVISION BY ZERO
ID - ILLEGAL DIRECT
TM - TYPE MISMATCH
LS - STRING TOO LONG
FD - FILE DATA (扩展I/O)
ST - STRING FORMULA TOO COMPLEX
CN - CAN'T CONTINUE
UF - UNDEFINED FUNCTION
```

## 5. 核心算法分析

### 5.1 表达式求值器（3164-3598行）

采用**运算符优先级法**（Operator Precedence Parsing）：

```
优先级表（OPTAB）:
121 - 加法/减法
123 - 乘法/除法
127 - 幂运算
80  - AND
70  - OR
125 - 取负（一元）
90  - NOT
100 - 关系运算符
```

**求值流程**:
1. FRMEVL - 表达式求值入口
2. EVAL - 求值单个值（数字、变量、字符串）
3. LPOPER - 循环处理运算符
4. PUSHF - 将中间结果压栈
5. PULSTK - 从栈中弹出并执行运算

**栈帧结构**（临时结果）:
```
[运算符例程地址]
[浮点数临时结果]
[运算符优先级]
```

### 5.2 变量管理（3599-3779行）

**变量命名**:
- 1-2个字符（第一个必须是字母）
- 字符串变量以 `$` 结尾
- 整数变量以 `%` 结尾（如果支持）
- 数组变量用括号标识

**查找过程** (PTRGET):
1. 从 VARTAB 开始搜索
2. 比较变量名（2字节）
3. 未找到则在 VARTAB 和 ARYTAB 之间插入新变量
4. 返回指向变量值的指针

### 5.3 数组处理（3780-4075行）

**数组描述符**:
```
[名称] (2字节)
[总长度] (2字节) - 包括描述符
[维数] (1字节)
[维度1上界] (2字节)
[维度2上界] (2字节) - 如果存在
...
[数据]
```

**多维索引计算**:
- 使用行主序（Row-major order）
- 公式：offset = (i1 * D2 * D3... + i2 * D3... + ... + in) * 元素大小
- 边界检查在运行时进行

### 5.4 字符串处理（4236-4790行）

**字符串描述符**（3字节）:
```
[长度] (1字节)
[地址] (2字节)
```

**垃圾回收**（GARBAG, 4362行起）:
1. 从 MEMSIZ 向下扫描
2. 标记所有活动字符串
3. 压缩字符串空间
4. 更新所有描述符指针

**临时字符串管理**:
- NUMTMP (3个) 临时描述符
- TEMPPT 指向第一个空闲临时描述符
- 表达式求值时自动管理

### 5.5 浮点运算（4845-6669行）

**加减法** (FADD, FSUB, 4899行起):
1. 对齐指数（较小数右移）
2. 尾数加减
3. 规范化结果
4. 四舍五入

**乘除法** (FMULT, FDIV, 5262行起):
1. 指数相加/减
2. 尾数乘/除（使用移位-加法）
3. 规范化
4. 符号处理

**三角函数** (6400行起):
- 使用泰勒级数/切比雪夫多项式
- 角度范围缩减
- 多项式求值器 (POLYX)

**随机数** (6287行起):
- 线性同余生成器
- 种子存储在 RNDX

## 6. 执行流程

### 6.1 初始化（6670-6954行）

```
1. 设置栈指针
2. 初始化跳转向量
3. 移动 CHRGET 到 RAM
4. 询问内存大小（或使用默认值）
5. 初始化字符串临时描述符
6. 执行 "NEW" 命令逻辑
7. 显示就绪提示
```

### 6.2 主循环（READY, 1515行附近）

```
1. 显示 "READY" 提示
2. 读取一行输入
3. 检查是否有行号：
   a. 有行号 → 插入/删除程序行
   b. 无行号 → 立即执行（直接模式）
4. 返回步骤1
```

### 6.3 语句执行（NEWSTT, 2131行附近）

```
1. 检查 CTRL-C（中断）
2. 获取下一个 token
3. 查找语句调度表（STMDSP）
4. 跳转到对应处理例程
5. 处理完返回 NEWSTT
```

### 6.4 CHRGET 机制（961-976行）

这是一个巧妙的自修改代码：

```assembly
CHRGET: INC TXTPTR      ; 增加文本指针
CHRGOT: LDA $xxxx       ; 加载当前字符（地址来自TXTPTR）
        CMP #':'        ; 比较
        BCS RETURN      ; >= ':' 则返回
        CMP #' '        ; 比较空格
        BEQ CHRGET      ; 跳过空格
        SEC
        SBC #'0'        ; 检查是否数字
        ...
```

- 高效获取下一个字符并跳过空格
- 自动检测数字
- 零页执行，速度快

## 7. 性能优化技巧

### 7.1 零页使用
- 所有频繁访问的变量放在零页（0-255）
- 零页寻址比绝对寻址快且代码更小

### 7.2 自修改代码
- CHRGET 中的 LDA 指令地址在运行时修改
- 避免间接寻址开销

### 7.3 Token化
- 减少内存使用
- 加快语句识别速度
- 关键字只需一次比较

### 7.4 栈式表达式求值
- 避免递归调用（6502没有硬件栈保护）
- 支持任意复杂表达式
- 运算符优先级自然处理

### 7.5 字符串垃圾回收
- 延迟回收，只在必要时执行
- 紧凑算法，一次扫描完成

## 8. 平台适配

使用条件编译实现多平台支持：

```assembly
REALIO=4    ; 4=Apple, 3=Commodore, 2=OSI, 1=KIM, 0=PDP-10
ROMSW=1     ; ROM版本开关
DISKO=0     ; 磁盘I/O支持
EXTIO=0     ; 扩展I/O
...

IFE REALIO-4,<  ; 如果是 Apple
    OUTCH=^O176755
    ...
>
```

## 9. 历史 Bug 修复记录

从代码注释中提取：

```
1978-07-27: 修复 FOR 循环变量在地址 FF 时匹配 RETURN 的严重 bug
1978-07-27: 修复 NEWSTT 处 CURLIN 设置前就检查的 bug
1978-07-01: 修复替换行时内存溢出导致链接错误的 bug
1978-07-01: 修复垃圾回收从不收集临时变量的 bug（Commodore bug #2）
1978-03-09: 修复 TRMPOS，允许 LEFT$/RIGHT$ 第二参数为0
1978-02-25: 修复 INPFLG 在 BUFPAG≠0 时设置错误
1978-02-11: 禁止保留字中有空格，特殊处理 "GO TO"
1978-02-11: 修复四舍五入可能增加字符串指针的 bug
1978-01-24: 修复未定义函数检查破坏错误号的问题
1977-12-01: 修复 PEEK 破坏 POKER 导致 POKE 失败
```

## 10. 用 Rust 重新实现的建议

基于以上分析，用 Rust 重新实现时应注意：

### 10.1 数据结构映射

```rust
// 值类型
enum Value {
    Integer(i16),           // 对应 INTFLG
    Float(f64),             // 对应 FAC
    String(String),         // 对应字符串描述符
}

// 变量存储
struct Variable {
    name: [u8; 2],          // 变量名
    value: Value,           // 值
}

// 数组
struct Array {
    name: [u8; 2],
    dimensions: Vec<usize>,
    data: Vec<Value>,
}

// 程序行
struct Line {
    number: u16,
    tokens: Vec<Token>,
}
```

### 10.2 关键模块

```rust
mod lexer;          // Token化，对应 CRUNCH
mod parser;         // 语法分析
mod evaluator;      // 表达式求值，对应 FRMEVL
mod runtime;        // 运行时环境
mod float;          // 浮点运算（可用标准库）
mod string_pool;    // 字符串管理，对应 GARBAG
mod variables;      // 变量管理，对应 PTRGET
```

### 10.3 优势

- **内存安全**: Rust 的所有权系统避免缓冲区溢出
- **现代浮点**: 使用 IEEE-754 而非自定义格式
- **更好的错误处理**: Result/Option 类型
- **更快的执行**: 现代编译器优化
- **可测试**: 单元测试框架

### 10.4 保留的设计

- Token化系统（节省内存）
- 运算符优先级解析（简单高效）
- 变量按名称哈希存储（快速查找）
- 程序行按链表结构存储（方便插入/删除）

## 11. 总结

这份 6502 BASIC 解释器源代码展示了：

1. **工程精妙性**: 在极其受限的硬件上实现完整的编程语言
2. **优化艺术**: 零页变量、自修改代码、紧凑的数据结构
3. **可移植性**: 通过条件编译支持多个平台
4. **鲁棒性**: 详细的错误处理和边界检查
5. **数学精度**: 软件实现的24位浮点运算

这是计算机历史上最有影响力的软件之一，值得深入研究和学习。
